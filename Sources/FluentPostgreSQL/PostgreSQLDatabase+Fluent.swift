extension DataColumn: Hashable {
    /// See `Equatable.`
    public static func ==(lhs: DataColumn, rhs: DataColumn) -> Bool {
        return lhs.table == rhs.table && lhs.name == rhs.name
    }
    
    /// See `Hashable.`
    public var hashValue: Int {
        if let table = table {
            return table.hashValue &+ name.hashValue
        } else {
            return name.hashValue
        }
    }
}


/// Adds ability to do basic Fluent queries using a `PostgreSQLDatabase`.
extension PostgreSQLDatabase: SQLSupporting {
    /// See `SQLDatabase`.
    public static func queryExecute(
        _ dml: DataManipulationQuery,
        on conn: PostgreSQLConnection,
        into handler: @escaping ([DataColumn: PostgreSQLData], PostgreSQLConnection) throws -> ()
    ) -> Future<Void> {
        // wait for the table name cache before continuing
        return PostgreSQLTableNameCache.get(for: conn).flatMap { tableNameCache in
            var binds = Binds()
            let sql = PostgreSQLSerializer().serialize(query: dml, binds: &binds)
            let params = try binds.values.map { encodable -> PostgreSQLData in
                guard let convertible = encodable as? PostgreSQLDataConvertible else {
                    throw PostgreSQLError(identifier: "dataConvertible", reason: "Could not convert \(type(of: encodable)) to PostgreSQL data.", source: .capture())
                }
                return try convertible.convertToPostgreSQLData()
            }
            
            return conn.query(sql, params) { row in
                var res: [DataColumn: PostgreSQLData] = [:]
                for (col, data) in row {
                    let field = DataColumn(table: tableNameCache.storage[col.tableOID], name: col.name)
                    res[field] = data
                }
                try handler(res, conn)
            }
        }
    }
    
    /// See `SQLDatabase`.
    public static func queryEncode<E>(_ encodable: E, entity: String) throws -> [DataManipulationColumn] where E: Encodable {
        return try PostgreSQLRowEncoder().encode(encodable, tableName: entity).map { row in
            if row.value.isNull {
                return .init(column: row.key, value: .null)
            } else {
                return .init(column: row.key, value: .binds([row.value]))
            }
        }
    }
    
    /// See `SQLDatabase`.
    public static func queryDecode<D>(_ data: [DataColumn: PostgreSQLData], entity: String, as decodable: D.Type) throws -> D
        where D: Decodable
    {
        return try PostgreSQLRowDecoder().decode(D.self, from: data, tableName: entity)
    }

    /// See `QuerySupporting.modelEvent`
    public static func modelEvent<M>(event: ModelEvent, model: M, on conn: PostgreSQLConnection) -> Future<M>
        where PostgreSQLDatabase == M.Database, M: Model
    {
        switch event {
        case .willCreate:
            if M.ID.self == UUID.self {
                var model = model
                model.fluentID = UUID() as? M.ID
                return conn.future(model)
            }
        case .didCreate:
            if M.ID.self == Int.self, model.fluentID == nil {
                return conn.simpleQuery("SELECT LASTVAL();").map(to: M.self) { row in
                    var model = model
                    try model.fluentID = row[0].firstValue(forColumn: "lastval")?.decode(Int.self) as? M.ID
                    return model
                }
            }
        default: break
        }

        return conn.future(model)
    }

    
    /// See `SQLSupporting`.
    public static func schemaDataType(for type: Any.Type, primaryKey: Bool) -> DataDefinitionDataType {
        guard let representable = type as? PostgreSQLDataConvertible.Type else {
            fatalError("""
                `\(type)` is not `PostgreSQLDataConvertible`.
                
                Suggested Fixes:
                - Conform \(type) to `PostgreSQLDataConvertible` to specify field type or implement a custom migration.
                - Specify the data type manually using the schema builder in a migration.
                """)
        }
        
        var dataType = DataDefinitionDataType(name: representable.postgreSQLDataType.knownSQLName ?? "VOID")
        
        if type as? AnyOptionalType.Type == nil {
            dataType.attributes.append("NOT NULL")
        }
        
        if primaryKey {
            if dataType.name.contains("INT") {
                if _globalEnableIdentityColumns {
                    dataType.attributes.append("GENERATED BY DEFAULT AS IDENTITY")
                } else {
                    dataType.name = dataType.name.replacingOccurrences(of: "INT", with: "SERIAL")
                }
            }
            dataType.attributes.append("PRIMARY KEY")
        }
        
        return dataType
        
    }
    
    /// See `SQLSupporting`.
    public static func schemaExecute(_ ddl: DataDefinitionQuery, on connection: PostgreSQLConnection) -> Future<Void> {
        let sql = PostgreSQLSerializer().serialize(query: ddl)
        return connection.query(sql).transform(to: ())
    }
    
    
    /// See `SQLSupporting`.
    public static func enableReferences(on connection: PostgreSQLConnection) -> Future<Void> {
        // enabled by default
        return .done(on: connection)
    }
    
    /// See `SQLSupporting`.
    public static func disableReferences(on connection: PostgreSQLConnection) -> Future<Void> {
        return Future.map(on: connection) {
            throw PostgreSQLError(identifier: "disableReferences", reason: "PostgreSQL does not support disabling foreign key checks.", source: .capture())
        }
    }
    
    /// See `SQLSupporting`.
    public static func transactionExecute<T>(_ transaction: @escaping (PostgreSQLConnection) throws -> Future<T>, on connection: PostgreSQLConnection) -> Future<T> {
        return connection.simpleQuery("BEGIN TRANSACTION").flatMap(to: T.self) { results in
            return try transaction(connection).flatMap(to: T.self) { res in
                return connection.simpleQuery("END TRANSACTION").transform(to: res)
                }.catchFlatMap { error in
                    return connection.simpleQuery("ROLLBACK").map(to: T.self) { results in
                        throw error
                    }
            }
        }
    }
}

extension PostgreSQLData: Encodable {
    /// See `Encodable`.
    public func encode(to encoder: Encoder) throws {
        var single = encoder.singleValueContainer()
        if let data = data {
            try single.encode(data)
        } else {
            try single.encodeNil()
        }
    }
}
